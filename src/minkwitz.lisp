;;;; minkwitz.lisp
;;;;
;;;; Copyright (c) 2019 Robert Smith

(in-package #:cl-permutation)

;;; This file contains an implementation of Minkwitz's algorithm.

;;;;;;;;;;;;;;;;;; Improved Generator Decomposition ;;;;;;;;;;;;;;;;;;

(defun minkwitz-table-quality (ν)
  (loop :for νᵢ :across ν
        :sum (loop :for img :being :the :hash-values :of νᵢ
                   :maximize (word-length img))))

(defun minkwitz-table-size (ν)
  ;; How many group elements does ν represent?
  (loop :with p := 1
        :for νᵢ :across ν
        :do (setf p (* p (hash-table-count νᵢ)))
        :finally (return p)))

(defun car* (x)
  (check-type x cons)
  (car x))

(defun stabilizer-orbits (group)
  "Compute a list of orbits corresponding to the BSGS of GROUP. In particular, calculate { i ↦ G⁽ⁱ⁾bᵢ₊₁ }."
  (multiple-value-bind (base sgs) (group-bsgs group)
    (loop :for b :in base
          :for s :in sgs
          :collect (loop :with orbit := nil
                         :for g :in s
                         :collect (map-orbit (lambda (p) (pushnew p orbit)) b g)
                         :finally (return (sort orbit #'<))))))

(declaim (ftype (function (t t) simple-vector) %make-minkwitz-table))
(defun %make-minkwitz-table (base orbits)
  (let* ((k (length base))
         (ν (make-array k)))
    (loop :for i :below k
          :for bᵢ :across base
          :for orbit :in orbits
          ;; The table maps points to words.
          :for table := (make-hash-table :test 'eql :size (length orbit))
          :do (setf (aref ν i) table)
              ;; We do *NOT* fill the table with sentinel values
              ;; because we use the *existence* of the entries as
              ;; indicators of completeness of filling the table.
              ;;
              ;; (CONS id NIL) ==> CAR is the item being stored, CDR
              ;; is whether it was newly generated by the algorithm.
              (setf (gethash bᵢ table) (cons nil nil)))
    ν))

(defun %compute-factorization-generators (group &key improve-every
                                                     (initial-length-limit 2.0)
                                                     (min-rounds 0)
                                                     (growth-factor 5/4)
                                                     (simplifier (word-simplifier-for-perm-group group)))
  ;;(declare (optimize (speed 0) safety debug))
  (declare (optimize speed (safety 0) (debug 0)))
  (declare (type (function (*) *) simplifier))

  ;; Deviations from Minkwitz's paper, and other implementation notes:
  ;;
  ;;     * We rename 'n' to MIN-ROUNDS, which dictates the *minimum*
  ;;       number of rounds to do. (A value of 0 indicates the
  ;;       algorithm should terminate immediately upon filling the
  ;;       table.)
  ;;
  ;;     * We rename 's' to IMPROVE-EVERY.
  ;;
  ;;     * We rename 'l' to LENGTH-LIMIT. Minkwitz gives no suggestion
  ;;       on what LENGTH-LIMIT ought to be, except that L should
  ;;       start small.
  ;;
  ;;     * We factor out GROWTH-FACTOR. 5/4 is no silver
  ;;       bullet. Minkwitz just says 'l' should grow slowly, and he
  ;;       uses 5/4 in his pseudocode.
  ;;
  ;;     * We add SIMPLIFIER, a function that allows words to be
  ;;       simplified. IDENTITY is perfectly reasonable as a simplifier.
  ;;
  ;;     * We relax the LENGTH-LIMIT condition so that the current
  ;;       word (as produced by NEXT) is always valid as a
  ;;       length. This is because we produce words in order of
  ;;       increasing length.
  ;;
  ;;     * We calculate all orbits of each transversal ahead of
  ;;       time. This is so we can determine whether we ought to
  ;;       explore it or not. (If the orbit is of length 1, then that
  ;;       transversal will only contain identity, so we shouldn't
  ;;       bother with it. See EXPLORE-INDEX? and EXPLORE-VEC.
  (check-type group                perm-group)
  (check-type improve-every        (or null (and fixnum unsigned-byte)))
  (check-type min-rounds           (and fixnum unsigned-byte))
  (check-type initial-length-limit (real (0) *))
  (check-type growth-factor        (real 1 *))

  (uiop:nest
   ;; Ensure LENGTH-LIMIT is a double float so it doesn't grow out of
   ;; control as a rational.
   (let* ((length-limit (coerce initial-length-limit 'double-float))
          (order (group-order group))
          (base (coerce (group-bsgs group) 'simple-vector))
          (k (length base))
          (free-group (perm-group.free-group group))
          (ϕ (free-group->perm-group-homomorphism free-group group))
          (next (alexandria:compose simplifier (word-generator free-group)))
          (orbits (stabilizer-orbits group))
          ;; If an orbit only has 1 element in it, then it's not worth
          ;; exploring. This vector should be accessed with
          ;; EXPLORE-INDEX?.
          (explore-vec (map 'simple-bit-vector
                            (lambda (x) (if (= 1 (length x)) 0 1))
                            orbits))
          ;; Set all νᵢ to be undefined, except νᵢ(bᵢ) = identity
          (ν (%make-minkwitz-table base orbits))
          ;; Minkwitz suggests that IMPROVE-EVERY is somewhat difficult to
          ;; choose, but K² works well in practice.
          (improve-every (or improve-every (* k k))))
     (declare (type double-float length-limit)
              (type (and fixnum unsigned-byte) k improve-every)
              (type (function (*) *) ϕ)
              (type simple-vector ν)
              (type simple-vector base)))
   ;; Utility functions...
   (flet ((explore-index? (i)
            ;; Should we explore elements in νᵢ?
            (= 1 (sbit explore-vec i)))
          (verify-table (where)
            (declare (optimize (speed 0) safety debug))
            (loop :for i :from 1 :to k
                  :for bᵢ :across base
                  :for νᵢ :across ν
                  :append (loop :for ω :being :the :hash-keys :of νᵢ
                                  :using (hash-value νᵢω)
                                :when (/= bᵢ (unsafe/perm-eval (funcall ϕ (car* νᵢω)) ω))
                                  :do (error "Table inconsistency at ~S: ν~D[ω=~D] /= ~D" where i ω bᵢ)))))
     (declare (inline explore-index?)))
   ;; Main logic...
   (labels ((%step (i tt)
              (declare (type fixnum i))
              ;; In the original paper, 'r' is a pass-by-reference. We
              ;; simply return it here.
              (setf tt (funcall simplifier tt))
              (let* ((νᵢ (aref ν (1- i)))
                     (bᵢ (svref base (1- i)))
                     (ω  (unsafe/perm-eval (funcall ϕ tt) bᵢ))
                     (tt⁻¹ (inverse free-group tt)))
                (declare (type hash-table νᵢ)
                         (type perm-element bᵢ ω))
                (symbol-macrolet ((b′ (gethash ω νᵢ)))
                  (cond
                    ((not (null b′))
                     (prog1 (values (compose free-group (car* b′) tt)) ;; original paper sez t*b′
                       (when (< (word-length tt) (word-length (car* b′)))
                         (setf b′ (cons tt⁻¹ t))
                         (%step i tt⁻¹))))
                    (t
                     (setf b′ (cons tt⁻¹ t))
                     (%step i tt⁻¹)
                     (values (identity-element free-group)))))))

            (%round (length-limit c tt)
              (declare (type double-float length-limit))
              ;; This function is supposed to receive tt by reference,
              ;; in the original paper. Not sure why...
              ;;
              ;; TT is a free-group word.
              ;; (assert (<= 1 c k))
              (setf tt (funcall simplifier tt))
              (loop :for i :from c :to k
                    :while (and (not (free-group-identity-p tt))
                                (< (word-length tt) length-limit))
                    :do (when (explore-index? (1- i))
                          (setf tt (%step i tt)))))

            (%improve (length-limit)
              (declare (type double-float length-limit))
              (dotimes (j k)
                (when (explore-index? j)
                  ;; XXX: Do we *need* to explore *every* pair in the
                  ;; cartesian product?
                  (loop :for x :of-type cons :being :the :hash-values :of (aref ν j) :do
                    (loop :for y :of-type cons :being :the :hash-values :of (aref ν j) :do
                      (when (or (cdr x) (cdr y))
                        ;; 1+j because it refers to the j'th stabilizer G⁽ʲ⁾
                        (%round length-limit (1+ j) (compose free-group (car* y) (car* x))))))
                  ;; Mark all of vⱼ as old.
                  (loop :for x :being :the :hash-values :of (aref ν j)
                        :do (rplacd x nil)))))

            (%fill-orbits (length-limit)
              (declare (type double-float length-limit))
              (loop :for i :below k
                    :for νᵢ :of-type hash-table :across ν
                    :for bᵢ :across base
                    :do (when (explore-index? i)
                          (let ((orb nil))
                            (loop :for y :being :the :hash-values :of νᵢ
                                  :do (pushnew (unsafe/perm-eval (funcall ϕ (car* y)) bᵢ) orb))
                            ;; At this point, every point in the orbit
                            ;; should be a key in the hash table.
                            (loop :for j :from (1+ i) :below k :do
                              (loop :for x :of-type cons :being :the :hash-values :of (aref ν j)
                                    :do (let* ((x (car* x))
                                               (x⁻¹ (inverse free-group x))
                                               (ϕx (funcall ϕ x))
                                               (orb-x (mapcar (perm-evaluator ϕx) orb)))
                                          (loop :for p :of-type perm-element :in (set-difference orb-x orb)
                                                :for orb-pt :of-type perm-element := (perm-inverse-eval ϕx p)
                                                :for tt := (funcall
                                                            simplifier
                                                            (compose free-group
                                                                     (car* (gethash orb-pt νᵢ))
                                                                     x⁻¹))
                                                :when (< (word-length tt) length-limit)
                                                  :do (setf (gethash p νᵢ) (cons tt t))))))))))

            (%table-fullp (ν)
              (let ((size (minkwitz-table-size ν)))
                (assert (<= size order))
                (= size order)))))
   (progn
     ;; The code starting here reflects Minkwitz's SGSWordQuick
     ;; procedure, except for the construction of ν, which is above.
     (loop :with start-time := (get-internal-real-time)
           :for count :of-type fixnum :from 1 :below most-positive-fixnum
           :until (and (%table-fullp ν) (<= min-rounds count))
           :do (let* ((tt (funcall next (1- count)))
                      (current-length-limit
                        (max length-limit (coerce (word-length tt) 'double-float))))
                 (%round current-length-limit 1 tt)
                 (when (zerop (mod count improve-every))
                   (when *perm-group-verbose*
                     (format t "~D: * * * Improving lengths...~%" count))
                   (%improve current-length-limit)
                   (unless (%table-fullp ν)
                     (when *perm-group-verbose*
                       (format t "~D: * * * Filling orbits...~%" count))
                     (%fill-orbits current-length-limit)
                     ;; Grow the length limit itself, not simply the
                     ;; current one for this round.
                     (setf length-limit (* growth-factor length-limit))))

                 ;; Some logging.
                 (when (and *perm-group-verbose*
                            (zerop (mod count (min 10000 improve-every))))
                   (format t "~D: [~3,1F%] @ l=~A: ~A [~D ms]~%    "
                           count
                           (* 100 (/ (minkwitz-table-size ν) (group-order group)))
                           (floor current-length-limit)
                           tt
                           (round (* 1000 (- (get-internal-real-time) start-time))
                                  internal-time-units-per-second))
                   (loop :with flag := nil
                         :for νᵢ :across ν
                         :for o :in orbits
                         :if (= 1 (length o))
                           :do (unless flag
                                 (format t " -")
                                 (setf flag t))
                         :else
                           :do (setf flag nil)
                               (format t " ~D" (hash-table-count νᵢ)))
                   (terpri)
                   (finish-output)
                   (setf start-time (get-internal-real-time)))))
     ;; Do a sanity check on the consistency of the table.
     (check-table "end")
     ;; Return the table, cleaning the usage flags out.
     (loop :for νᵢ :across ν
           :do (maphash (lambda (k v)
                          (setf (gethash k νᵢ) (car v)))
                        νᵢ))
     (when *perm-group-verbose*
       (format t "Table quality: ~D~%" (minkwitz-table-quality ν)))
     ν)))

(defun compute-factorization-generators (group)
  "Modify the permutation group PERM-GROUP so that it is capable of factorizing elements into generators."
  (unless (perm-group.factorization-generators group)
    (setf (perm-group.factorization-generators group)
          (%compute-factorization-generators group)))
  t)

;;; TODO: call simplifier
(defun generator-decomposition (g group &key return-original-generators)
  "Given an element g ∈ GROUP, factorize it into a sequence of generators, represented as a list of elements in the homomorphic FREE-GROUP.

If RETURN-ORIGINAL-GENERATORS is true, return the group's original generators as permutations.

This is also called \"factorization\"."
  (check-type g perm)
  (check-type group perm-group)
  (compute-factorization-generators group)
  (let* ((fg (perm-group.free-group group))
         (ϕ (free-group->perm-group-homomorphism fg group))
         (ν (perm-group.factorization-generators group)))
    (labels ((walk-stabilizer (i π base-left factorization)
               (cond
                 ((null base-left)
                  (assert (perm-identity-p π)
                          ()
                          "Inconsistency in GENERATOR-DECOMPOSITION. Possibly an issue with the table?")
                  (inverse fg (remove-if #'free-group-identity-p
                                         (canonicalize-free-group-element
                                          fg
                                          factorization))))
                 (t
                  (let* ((νᵢ (aref ν i))
                         (bᵢ (first base-left))
                         (ωᵢ (unsafe/perm-eval π bᵢ))
                         (νᵢωᵢ (gethash ωᵢ νᵢ))
                         (νᵢπ (perm-compose (funcall ϕ νᵢωᵢ) π)))
                    (walk-stabilizer (1+ i) νᵢπ (rest base-left) (cons νᵢωᵢ factorization)))))))
      (let ((decomp (walk-stabilizer 0
                                     g
                                     (group-bsgs group)
                                     nil)))
        (if (not return-original-generators)
            decomp
            (mapcar ϕ decomp))))))
