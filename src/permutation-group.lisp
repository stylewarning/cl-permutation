;;;; permutation-group.lisp
;;;;
;;;; Copyright (c) 2012-2018 Robert Smith

(in-package #:cl-permutation)

(defvar *perm-group-verbose* nil)

;;; A TRANSVERSAL SYSTEM (trans) is represented as an alist, which
;;; takes a K and returns a table which takes a J and returns
;;; sigma_kj. That is
;;;
;;;    K -> (J -> sigma_kj)

(defclass perm-group ()
  ((element-size :initarg :element-size
                 :accessor perm-group.element-size
                 :documentation "The size of the elements of the group. This is a non-negative integer and may be larger than the true degree of the group.")
   (generators :initarg :generators
               :accessor perm-group.generators
               :documentation "A list of generators of the group.")
   (strong-generators :initarg :strong-generators
                      :accessor perm-group.strong-generators
                      :documentation "The strong generating set of the group. This is a vector mapping integers to lists of generators which generate the i'th stabilizer.")
   (transversal-system :initarg :transversal-system
                       :accessor perm-group.transversal-system
                       :documentation "The transversal system of the group. This is a vector mapping integers K to a table of sigmas SIGMA_K. Every permutation in the group can be represented by a product of permutations SIGMA_K * ... * SIGMA_2 * SIGMA_1.")
   (free-group :initarg :free-group
               :accessor perm-group.free-group
               :documentation "A free group corresponding to the given permutation group.")
   (factorization-generators :initarg :factorization-generators
                             :accessor perm-group.factorization-generators
                             :documentation "A vector whose length is the same length as the base of the group, whose values are vectors of free-group elements that are coset representatives of the stabilizer G^(i+1)/G^(i). This collection of generators is *also* a strong generating set. This is optionally computed with #'COMPUTE-FACTORIZATION-GENERATORS."
                             :initform nil)
   (slp-context :initarg :slp-context
                :accessor perm-group.slp-context
                :documentation "SLPs corresponding to all sigmas and strong generators."))
  (:documentation "Representation of a permutation group generated by a finite number of generators."))

(defun group-degree (group &key true)
  "What is the degree of the group GROUP?

If TRUE is a true-value, then the true degree will be returned (i.e., the maximum non-fixed point index). For example, consider

    G = <(1 3 2 4 5)>

then

    (group-degree G :true nil) ==> 5  [default]
    (group-degree G :true t)   ==> 3."
  (if true
      (maximum (perm-group.generators group) :key #'perm-last-non-fixpoint)
      (perm-group.element-size group)))

(defun group-identity (group)
  "Return the identity element of the group GROUP."
  (perm-identity (group-degree group :true nil)))

;;; Implementation of the group protocol.

(defmethod identity-element ((g perm-group))
  (group-identity g))

(defmethod compose ((g perm-group) a b)
  (perm-compose a b))

(defmethod inverse ((g perm-group) a)
  (perm-inverse a))

(defmethod generators ((g perm-group))
  (copy-list (perm-group.generators g)))

(defmethod num-generators ((g perm-group))
  (length (perm-group.generators g)))

(defmethod print-object ((group perm-group) stream)
  (print-unreadable-object (group stream :type t :identity nil)
    (format stream "of ~D generator~:p" (num-generators group))))


;;;;;;;;;;;;;;; Transversal Systems and Schreier-Sims ;;;;;;;;;;;;;;;;

(deftype transversal ()
  ;; It could actually be (simple-array list (*)), but
  ;; we will want to use SVREF. While such a type would collapse into
  ;; SIMPLE-VECTOR in most implementations, we don't want to assume
  ;; such.
  ;;
  ;; Elements of the transversal are constructed by MAKE-SIGMA-TABLE.
  `simple-vector)

(deftype sgs ()
  ;; vector of lists of perms
  `simple-vector)

(declaim (inline make-transversal))
(defun make-transversal (n)
  "Make a transversal of size N."
  (make-array n :initial-element nil))

(declaim (inline transversal-ref))
(defun transversal-ref (trans k)
  "Get the Kth element of the transversal TRANS. This is representative of all sigma_k."
  (declare (type transversal trans))
  (svref trans (1- k)))

(defun (setf transversal-ref) (new-value trans k)
  (declare (type transversal trans))
  (setf (svref trans (1- k)) new-value))

(declaim (inline make-sgs))
(defun make-sgs (n)
  "Make a strong generating set of size N."
  (make-array n :initial-element nil))

(declaim (inline sgs-ref))
(defun sgs-ref (sgs k)
  (svref sgs (1- k)))

(defun (setf sgs-ref) (new-value sgs k)
  (setf (svref sgs (1- k)) new-value))

(defun make-sigma-table (k &optional (identity (perm-identity k)))
  "Make a representation of sigma_K, initialized witk sigma_KK = identity.

The optional argument IDENTITY allows the caller to provide the identity permutation for sigma_kk.

This is represented as an alist mapping J to permutations sigma_KJ."
  (acons k identity nil))

;;; SIGMAs are elements of the transversal system. A SIGMA is either
;;; NIL or some permutation that maps K to J.
(defun sigma (trans k j)
  "Retrieve sigma_kj for the transversal system TRANS, or NIL if it doesn't exist."
  (let ((sigma_k (transversal-ref trans k)))
    (cdr (assoc j sigma_k))))

(defun (setf sigma) (new-value trans k j)
  (let* ((sigma_k (transversal-ref trans k))
         (sigma_kj (assoc j sigma_k)))
    (if (null sigma_kj)
        (setf (transversal-ref trans k) (acons j new-value sigma_k))
        (rplacd sigma_kj new-value)))
  new-value)

(defun sigma-symbol (k j)
  "Return a symbol representing sigma_kj. This is used for perms that are added to the transversal system during group construction."
  (alexandria:format-symbol ':keyword "SIGMA_(~D,~D)" k j))

(defun tau-symbol ()
  "Return a freshly made symbol for tau."
  (gensym "TAU-"))

(defun reduce-over-trans-decomposition (f initial-value perm trans &optional (k (perm-size perm)))
  "Reduce F over the transversal decomposition of PERM within the transversal system TRANS. Return two values:

    1. The result of folding over, or NIL if no decomposition exists.
    2. NIL iff no decomposition exists.

F is a function of three arguments:

    ACCUM: The \"accumulator\" argument. INITIAL-VALUE is the initial value of this argument.
    K, J : Two arguments representing the sigma.

N.B.! The sigma_kj are visited in \"right-to-left\" compositional order. That is, if S1, S2, ..., Sk are visited sequentially, then PERM is the composition Sk * ... * S2 * S1."
  (labels ((next (perm k acc)
             (if (zerop k)
                 (values acc t)
                 (let* ((j (perm-eval perm k))
                        (sigma_kj (sigma trans k j)))
                   (if (null sigma_kj)
                       (values nil nil)
                       (next (if (= j k)
                                 perm
                                 (perm-compose (perm-inverse sigma_kj) perm))
                             (1- k)
                             (funcall f acc k j)))))))
    (declare (dynamic-extent #'next))
    (next perm k initial-value)))

(defun trans-decomposition (perm trans &optional (k (perm-size perm)))
  "Decompose PERM into a list of sigmas within the transversal system TRANS. The composition of the sigmas equals the original perm up to K.

The sigma (SIGMA K J) is represented by the cons cell (K . J)."
  ;; XXX: Could avoid NREVERSE by collecting more cleverly.
  (flet ((collector (decomp k j)
           (acons k j decomp)))
    (declare (dynamic-extent #'collector))
    (nreverse (reduce-over-trans-decomposition #'collector nil perm trans k))))

(defun trans-element-p (perm trans &optional (k (perm-size perm)))
  #+#:equivalent (not (null (trans-decomposition perm trans k)))
  (values
   (reduce-over-trans-decomposition
    (load-time-value (constantly t))
    t
    perm
    trans
    k)))

(defvar *context*)
(setf (documentation '*context* 'variable)
      "Special variable used to hold the context being built up for a group.")

(defvar *taus*)
(setf (documentation '*taus* 'variable)
      "Special variable used to hold a mapping between permutation objects (by EQ) to a symbol (one generated by #'TAU-SYMBOL) which is referred to by the SLP context.")

;;; For #'ADD-GENERATOR and #'UPDATE-TRANSVERSAL:
;;;
;;;   * PERM: the perm to introduce to the SGS and transversal system.
;;;
;;;   * SGS: the strong generating set
;;;
;;;   * TRANS: the transversal system
;;;
;;;   * K: All points above K should be fixpoints. K is what is
;;;        recursed on.
;;;
;;;   * SLP: An SLP to construct PERM. Used for recording purposes.
;;;
;;; Both return an updated SGS and transversal system as two values.
;;;
;;; Both also use *CONTEXT* to record SLPs, which is expected to be
;;; bound to. This is indeed the case by the main entry point
;;; #'GENERATE-PERM-GROUP.

;;; Algorithm B from Knuth, with my own modifications.
(defun add-generator (perm sgs trans k slp)
  ;; Add the perm to the SGS.
  (pushnew perm (sgs-ref sgs k))

  ;; Generate a new tau for the perm, and remember it.
  (let ((t-sym (tau-symbol)))
    (setf (gethash perm *taus*) t-sym)
    (setf (symbol-assignment *context* t-sym) slp))

  ;; Process the perm, adding it to the group structure.
  (let ((redo nil))
    (loop
      (loop :for (j . s) :in (transversal-ref trans k)
            :for s-sym := (sigma-symbol k j) :do
              (dolist (tau (sgs-ref sgs k))
                (let ((prod (perm-compose tau s)))
                  (unless (trans-element-p prod trans)
                    (let* ((t-sym (gethash tau *taus*))
                           (prod-slp (compose-slp (slp-symbol t-sym)
                                                  (slp-symbol s-sym))))
                      (multiple-value-setq (sgs trans)
                        (update-transversal prod sgs trans k prod-slp)))

                    (setf redo t)))))

      ;; Break out?
      (unless redo
        (return-from add-generator (values sgs trans)))

      ;; Reset the REDO flag.
      (setf redo nil))))

;;; Algorithm B from Knuth, with my own modifications.
(defun update-transversal (perm sgs trans k slp)
  (let* ((j (perm-eval perm k))
         (sigma (sigma trans k j)))
    (cond
      ((not (null sigma))
       (let ((new-perm (%perm-compose-upto
                        (perm-inverse sigma)
                        perm
                        (1- k))))
         (if (trans-element-p new-perm trans (1- k))
             (values sgs trans)
             (let ((new-perm-slp (compose-slp
                                  (invert-slp
                                   (slp-symbol (sigma-symbol k j)))
                                  slp)))
               (add-generator new-perm sgs trans (1- k) new-perm-slp)))))
      (t
       (setf (sigma trans k j) perm)
       (setf (symbol-assignment *context* (sigma-symbol k j))
             slp)
       (values sgs trans)))))

(defun generate-perm-group (generators)
  "Generate a permutation group generated by the list of permutations GENERATORS."
  (let* ((n (maximum generators :key 'perm-size))
         (sgs (make-sgs n))
         (trans (make-transversal n))
         (fg (make-free-group (length generators)))
         (*context* (make-instance 'slp-context))
         (*taus* (make-hash-table :test 'eq)))
    ;; Initialize TRANS to map sigma_KK: K -> (K -> Identity(K)).
    ;;
    ;; Also record their SLPs as (SLP-ELEMENT <fg identity>).
    (loop :for k :from 1 :to n :do
      (setf (transversal-ref trans k) (make-sigma-table k))
      (setf (symbol-assignment *context* (sigma-symbol k k))
            (slp-element (identity-element fg))))

    ;; Add the generators.
    ;;
    ;; We iterate through the generators of the induced free group
    ;; as well purely to record SLPs. We can then construct a
    ;; homomorphism from the free group to the perm group to
    ;; construct elements from their generators.
    (loop :for generator :in generators
          :for fg-generator :in (generators fg)
          :do (multiple-value-setq (sgs trans)
                (add-generator generator
                               sgs
                               trans
                               n
                               (slp-element fg-generator))))

    ;; Return the group.
    (make-instance 'perm-group
                   :element-size (maximum generators :key #'perm-size)
                   :generators (copy-list generators)
                   :strong-generators sgs
                   :transversal-system trans
                   :slp-context *context*
                   :free-group fg)))

(defun group-bsgs (perm-group)
  "Retrieve a base and associated strong generating set (BSGS) as two values respectively for the permutation group PERM-GROUP."
  (loop :with base := nil
        :with sgs  := nil
        :for k :from 1
        :for k-generators :across (perm-group.strong-generators perm-group)
        :when k-generators :do
          (push k base)
          (push k-generators sgs)
        :finally (return
                   (values (nreverse base)
                           (nreverse sgs)))))

(defun group-from (generators-as-lists)
  "Generate a permutation group from a list of generators, which are represented as lists."
  (generate-perm-group (mapcar #'list-to-perm generators-as-lists)))

;;; TODO: Automatically try calculating size.
(defun group-from-cycles (generators-as-cycles size)
  "Generate a permutation group from a list of generators, which are represented as cycles."
  (generate-perm-group (mapcar (lambda (c)
                                 (from-cycles c size))
                               generators-as-cycles)))

(defun group-order (group)
  "Compute the order of the permutation group GROUP."
  (let ((transversals (perm-group.transversal-system group)))
    (product transversals :key #'length)))

(defun group-element-p (perm group)
  "Decide if the permutation PERM is an element of the group GROUP."
  (trans-element-p perm (perm-group.transversal-system group)))

(defun subgroup-p (group subgroup)
  "Is the group SUBGROUP a subgroup of GROUP?"
  (every (lambda (g) (group-element-p g group))
         (generators subgroup)))

;;; XXX FIXME: Avoid consing here.
(defun random-group-element (group)
  "Generate a random element of the group GROUP."
  (reduce #'perm-compose-flipped
          (perm-group.transversal-system group)
          :initial-value (group-identity group)
          :key (lambda (sigma_k) (cdr (random-element sigma_k)))))

;;; XXX: This can be made more efficient by directly reducing over,
;;; removing identities within the fold function.
(defun transversal-decomposition (perm group &key remove-identities)
  "Decompose the permutation PERM into transversal sigmas of the group GROUP."
  (let ((decomp
          (trans-decomposition perm (perm-group.transversal-system group))))
    (if (not remove-identities)
        decomp
        (delete-if (lambda (sigma)
                     (= (car sigma)
                        (cdr sigma)))
                   decomp))))


;;;;;;;;;;;;;;;;; Generator Decomposition Using SLPs ;;;;;;;;;;;;;;;;;

;;; These functions are for pedagogy.

(defun free-group-generator-to-perm-group-generator (perm-group free-group-generator)
  "Convert the free group generator FREE-GROUP-GENERATOR to a generator within the perm group PERM-GROUP."
  (let ((i free-group-generator))
    (cond
      ((zerop i) (group-identity perm-group))
      ((plusp i) (elt (generators perm-group) (1- i)))
      ((minusp i) (perm-inverse
                   (free-group-generator-to-perm-group-generator
                    perm-group
                    (- i)))))))

;; FIXME: We should improve this to use the stuff from
;; homomorphism.lisp, maybe.
(defun free-group->perm-group-homomorphism (free-group perm-group)
  "Construct a homomorphism from the perm group PERM-GROUP's free group to elements of the perm group itself."
  (assert (= (num-generators free-group)
             (num-generators perm-group))
          (free-group perm-group)
          "The free group and the perm group must have the ~
           same number of generators.")
  ;; The perm group contains the free group.
  (lambda (elts)
    (typecase elts
      (integer (free-group-generator-to-perm-group-generator
                perm-group
                elts))
      (list (loop :with result := (group-identity perm-group)
                  :for i :in elts
                  :do (setf result
                            (perm-compose result
                                          (free-group-generator-to-perm-group-generator perm-group i)))
                  :finally (return result))))))

(defun naive-generator-decomposition (perm group &key return-original-generators)
  "Compute the generator decomposition of the permutation PERM of the group GROUP. By default, return a sequence of free generators.

If RETURN-ORIGINAL-GENERATORS is true, return the group's original generators as permutations.

Note: The result is likely very long and inefficient."
  (let* ((d (transversal-decomposition perm group :remove-identities t))
         (ctx (perm-group.slp-context group))
         (fg (perm-group.free-group group))
         (hom (free-group->perm-group-homomorphism fg group)))
    (labels ((to-sigma-symbol (tt)
               (sigma-symbol (car tt) (cdr tt)))
             (find-slp (tt)
               (symbol-assignment ctx (to-sigma-symbol tt)))
             (eval-slp (slp)
               (evaluate-slp fg ctx slp)))
      (mapcar (if return-original-generators hom #'identity) ; Free -> Perm
              (delete (identity-element fg) ; Remove identities.
                      (mapcan #'eval-slp    ; Eval SLPs
                              (mapcar #'find-slp d)))))))

;;;;;;;;;;;;;;;;;; Improved Generator Decomposition ;;;;;;;;;;;;;;;;;;

(defun word-length (w)
  (cond
    ((integerp w) 1)
    ((listp w) (max 1 (length w)))
    (t (error "invalid word: ~A" w))))

(defun word-generator (group)
  (check-type group free-group)
  (let* ((b/2 (free-group-num-generators group))
         (b (* 2 b/2)))
    (labels ((process (x)
               (if (<= x b/2)
                   x
                   (- b/2 x)))
             (words-in-level (l)
               (expt b l))
             (words-below-level (l)
               (loop :for i :below l :sum (words-in-level i)))
             (find-level (n)
               (if (zerop n)
                   0
                   (loop :for l :from 0
                         :when (<= (words-below-level l)
                                   n
                                   (1- (words-below-level (1+ l))))
                           :do (return l))))
             (generate (n l)
               (let ((n (- n (words-below-level l))))
                 (loop :repeat l
                       :collect (multiple-value-bind (quo rem) (floor n b)
                                  (setf n quo)
                                  (1+ rem))))))
      (lambda (n)
        (mapcar #'process (generate n (find-level n)))))))


;; TODO FIXME: This isn't fully working or implemented.
(defun %compute-factorization-generators (group &key max-rounds
                                                     improve-every
                                                     l)
  (declare (optimize (speed 0) safety debug))

  ;; every s rounds, improve
  ;;
  ;; l should be small in the beginning and grow slowly; small l
  ;; terminates rounds earlier.
  (check-type group perm-group)
  (check-type max-rounds (or null integer))
  (check-type improve-every (or null integer))
  (check-type l (or null real))
  (uiop:nest
   (let* ((deg (group-degree group))
          (base (group-bsgs group))
          (k (length base))
          (free-group (perm-group.free-group group))
          (ϕ (free-group->perm-group-homomorphism free-group group))
          (next (word-generator free-group))
          (ν nil)))
   (labels ((%step (i tt)
              (check-type i unsigned-byte)
              (assert (free-group-element-valid-p free-group tt))
              (assert (<= 1 i k))
              ;; tt is a free group word
              (let* ((νᵢ (aref ν (1- i)))
                     (bᵢ (elt base (1- i)))
                     (ω (perm-eval (funcall ϕ tt) bᵢ)))
                (symbol-macrolet ((b′ (aref νᵢ (1- ω))))
                  (cond
                    ((not (null b′))
                     (prog1 (compose free-group (car b′) tt)
                       (when (< (word-length tt) (word-length (car b′)))
                         (setf b′ (cons (inverse free-group tt) t))
                         (%step i (inverse free-group tt)))))
                    (t
                     (setf b′ (cons (inverse free-group tt) t))
                     (%step i (inverse free-group tt))
                     (identity-element free-group))))))

            (%round (l c tt)
              (check-type l real)
              (check-type c unsigned-byte)
              (assert (<= 1 c k))
              ;; tt is a free group word
              (loop :while (and (not (free-group-identity-p tt))
                                (< (word-length tt) l)
                                (<= c k)) ; is this right?
                    :do (setf tt (%step c tt))
                        (incf c)))

            (%improve (l)
              (dotimes (j k)
                (loop :for x :across (aref ν j) :do
                  (when x
                    (loop :for y :across (aref ν j) :do
                      (when y
                        (when (or (cdr x) (cdr y))
                          (rplacd x nil)
                          (rplacd y nil)
                          ;; 1+j because it refers to the j'th stabilizer G⁽ʲ⁾
                          (%round l (1+ j) (compose free-group (car y) (car x))))))))))

            (%fill-orbits (l)
              (loop :for i :below k
                    :for bᵢ :in base
                    :for νᵢ := (aref ν i)
                    :do (let ((orb (delete-duplicates
                                    (loop :for y :across νᵢ
                                          :when y
                                            :collect (perm-eval (funcall ϕ (car y)) bᵢ)))))
                          (loop :for j :from (1+ i) :below k :do
                            (loop :for x :across (aref ν j) :do
                              (when x
                                (let* ((x (car x))
                                       (ϕx (funcall ϕ x))
                                       (ϕx⁻¹ (perm-inverse ϕx)))
                                  (dolist (p (set-difference
                                              (mapcar (lambda (o) (perm-eval ϕx o)) orb)
                                              orb))
                                    (let ((tt (compose
                                               free-group
                                               x
                                               (car (aref νᵢ (1- (perm-eval ϕx⁻¹ p)))))))
                                      (when (< (word-length tt) l)
                                        (setf (aref νᵢ (1- p))
                                              (cons (inverse free-group tt) t))))))))))))

            (%table-fullp ()
              (let ((size (%table-size))
                    (order (group-order group)))
                (assert (<= size order))
                (= size order)))

            (%table-size ()
              (loop :with p := 1
                    :for νᵢ :across ν
                    :do (setf p (* p (count-if-not #'null νᵢ)))
                    :finally (return p)))

            (%make-table ()
              (let ((ν′ (make-array
                         k
                         :initial-contents (loop
                                             :repeat k
                                             :collect (make-array
                                                       deg
                                                       :initial-element nil)))))
                (loop :for b :in base
                      :for νᵢ :across ν′ :do
                        ;; (CONS 0 NIL) ==> CAR is the item being
                        ;; stored, CDR is whether it was newly
                        ;; generated by the algorithm.
                        (setf (aref νᵢ (1- b)) (cons (identity-element free-group) nil)))
                (setf ν ν′)))))
   (progn
     (when (null improve-every) (setf improve-every (* k k)))
     (when (null l) (setf l 2))
    ;; set all νᵢ to be undefined, except νᵢ(bᵢ) = identity
    (%make-table)
    (loop :for count :from 1
          :while (if (null max-rounds)
                     (not (%table-fullp))
                     (or (<= count max-rounds) (not (%table-fullp))))
          :do (let ((tt (funcall next count)))
                (%round l 1 tt)
                (when (zerop (mod count improve-every))
                  (when *perm-group-verbose*
                    (format t "p[~3,1F] @ ~A: ~A~%"
                            (* 100 (/ (%table-size) (group-order group)))
                            (round l)
                            tt))
                  (%improve l)
                  (unless (%table-fullp)
                    #+ig
                    (%fill-orbits l)
                    (setf l (* 101/100 l))
                    ))))
    ;; Return the table, cleaning the usage flags out.
    (loop :for νᵢ :across ν
          :do (map-into νᵢ #'car νᵢ))
    ν)))

(defun compute-factorization-generators (group)
  "Modify the permutation group PERM-GROUP so that it is capable of factorizing elements into generators."
  (unless (perm-group.factorization-generators group)
    (setf (perm-group.factorization-generators group)
          (%compute-factorization-generators group)))
  t)

(defun generator-decomposition (g group &key return-original-generators)
  "Given an element g ∈ GROUP, factorize it into a sequence of generators, represented as a list of elements in the homomorphic FREE-GROUP.

If RETURN-ORIGINAL-GENERATORS is true, return the group's original generators as permutations.

This is also called \"factorization\"."
  (check-type g perm)
  (check-type group perm-group)
  (compute-factorization-generators group)
  (let* ((fg (perm-group.free-group group))
         (ϕ (free-group->perm-group-homomorphism fg group))
         (ν (perm-group.factorization-generators group)))
    (labels ((walk-stabilizer (i π base-left factorization)
               (cond
                 ((null base-left)
                  (assert (perm-identity-p π)
                          ()
                          "Inconsistency in FACTORIZE. Possibly an issue with the table?")
                  (inverse fg (remove-if #'free-group-identity-p
                                         (canonicalize-free-group-element
                                          fg
                                          factorization))))
                 (t
                  (let* ((νᵢ (aref ν i))
                         (bᵢ (first base-left))
                         (ωᵢ (perm-eval π bᵢ))
                         (νᵢωᵢ (aref νᵢ (1- ωᵢ)))
                         (νᵢπ (perm-compose (funcall ϕ νᵢωᵢ) π)))
                    (walk-stabilizer (1+ i) νᵢπ (rest base-left) (cons νᵢωᵢ factorization)))))))
      (let ((decomp (walk-stabilizer 0
                                     g
                                     (group-bsgs group)
                                     nil)))
        (if (not return-original-generators)
            decomp
            (mapcar ϕ decomp))))))
