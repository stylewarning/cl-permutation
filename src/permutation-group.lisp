;;;; permutation-group.lisp
;;;;
;;;; Copyright (c) 2012-2018 Robert Smith

(in-package #:cl-permutation)

(defvar *perm-group-verbose* nil)

;;; A TRANSVERSAL SYSTEM (trans) is represented as an alist, which
;;; takes a K and returns a table which takes a J and returns
;;; sigma_kj. That is
;;;
;;;    K -> (J -> sigma_kj)

(defclass perm-group ()
  ((element-size :initarg :element-size
                 :accessor perm-group.element-size
                 :documentation "The size of the elements of the group. This is a non-negative integer and may be larger than the true degree of the group.")
   (generators :initarg :generators
               :accessor perm-group.generators
               :documentation "A list of generators of the group.")
   (strong-generators :initarg :strong-generators
                      :accessor perm-group.strong-generators
                      :documentation "The strong generating set of the group. This is a vector mapping integers to lists of generators which generate the i'th stabilizer.")
   (transversal-system :initarg :transversal-system
                       :accessor perm-group.transversal-system
                       :documentation "The transversal system of the group. This is a vector mapping integers K to a table of sigmas SIGMA_K. Every permutation in the group can be represented by a product of permutations SIGMA_K * ... * SIGMA_2 * SIGMA_1.")
   (free-group :initarg :free-group
               :accessor perm-group.free-group
               :documentation "A free group corresponding to the given permutation group.")
   (factorization-generators :initarg :factorization-generators
                             :accessor perm-group.factorization-generators
                             :documentation "A vector whose length is the same length as the base of the group, whose values are vectors of free-group elements that are coset representatives of the stabilizer G^(i+1)/G^(i). This collection of generators is *also* a strong generating set. This is optionally computed with #'COMPUTE-FACTORIZATION-GENERATORS."
                             :initform nil)
   (slp-context :initarg :slp-context
                :accessor perm-group.slp-context
                :documentation "SLPs corresponding to all sigmas and strong generators."))
  (:documentation "Representation of a permutation group generated by a finite number of generators."))

(defun group-degree (group &key true)
  "What is the degree of the group GROUP?

If TRUE is a true-value, then the true degree will be returned (i.e., the maximum non-fixed point index). For example, consider

    G = <(1 3 2 4 5)>

then

    (group-degree G :true nil) ==> 5  [default]
    (group-degree G :true t)   ==> 3."
  (if true
      (maximum (perm-group.generators group) :key #'perm-last-non-fixpoint)
      (perm-group.element-size group)))

(defun group-identity (group)
  "Return the identity element of the group GROUP."
  (perm-identity (group-degree group :true nil)))

;;; Implementation of the group protocol.

(defmethod identity-element ((g perm-group))
  (group-identity g))

(defmethod compose ((g perm-group) a b)
  (perm-compose a b))

(defmethod inverse ((g perm-group) a)
  (perm-inverse a))

(defmethod generators ((g perm-group))
  (copy-list (perm-group.generators g)))

(defmethod num-generators ((g perm-group))
  (length (perm-group.generators g)))

(defmethod print-object ((group perm-group) stream)
  (print-unreadable-object (group stream :type t :identity nil)
    (format stream "of ~D generator~:p" (num-generators group))))


;;;;;;;;;;;;;;; Transversal Systems and Schreier-Sims ;;;;;;;;;;;;;;;;

(deftype transversal ()
  ;; It could actually be (simple-array list (*)), but
  ;; we will want to use SVREF. While such a type would collapse into
  ;; SIMPLE-VECTOR in most implementations, we don't want to assume
  ;; such.
  ;;
  ;; Elements of the transversal are constructed by MAKE-SIGMA-TABLE.
  `simple-vector)

(deftype sgs ()
  ;; vector of lists of perms
  `simple-vector)

(declaim (inline make-transversal))
(defun make-transversal (n)
  "Make a transversal of size N."
  (make-array n :initial-element nil))

(declaim (inline transversal-ref))
(defun transversal-ref (trans k)
  "Get the Kth element of the transversal TRANS. This is representative of all sigma_k."
  (declare (type transversal trans))
  (svref trans (1- k)))

(defun (setf transversal-ref) (new-value trans k)
  (declare (type transversal trans))
  (setf (svref trans (1- k)) new-value))

(declaim (inline make-sgs))
(defun make-sgs (n)
  "Make a strong generating set of size N."
  (make-array n :initial-element nil))

(declaim (inline sgs-ref))
(defun sgs-ref (sgs k)
  (svref sgs (1- k)))

(defun (setf sgs-ref) (new-value sgs k)
  (setf (svref sgs (1- k)) new-value))

(defun make-sigma-table (k &optional (identity (perm-identity k)))
  "Make a representation of sigma_K, initialized witk sigma_KK = identity.

The optional argument IDENTITY allows the caller to provide the identity permutation for sigma_kk.

This is represented as an alist mapping J to permutations sigma_KJ."
  (acons k identity nil))

;;; SIGMAs are elements of the transversal system. A SIGMA is either
;;; NIL or some permutation that maps K to J.
(defun sigma (trans k j)
  "Retrieve sigma_kj for the transversal system TRANS, or NIL if it doesn't exist."
  (let ((sigma_k (transversal-ref trans k)))
    (cdr (assoc j sigma_k))))

(defun (setf sigma) (new-value trans k j)
  (let* ((sigma_k (transversal-ref trans k))
         (sigma_kj (assoc j sigma_k)))
    (if (null sigma_kj)
        (setf (transversal-ref trans k) (acons j new-value sigma_k))
        (rplacd sigma_kj new-value)))
  new-value)

(defun sigma-symbol (k j)
  "Return a symbol representing sigma_kj. This is used for perms that are added to the transversal system during group construction."
  (alexandria:format-symbol ':keyword "SIGMA_(~D,~D)" k j))

(defun tau-symbol ()
  "Return a freshly made symbol for tau."
  (gensym "TAU-"))

(defun reduce-over-trans-decomposition (f initial-value perm trans &optional (k (perm-size perm)))
  "Reduce F over the transversal decomposition of PERM within the transversal system TRANS. Return two values:

    1. The result of folding over, or NIL if no decomposition exists.
    2. NIL iff no decomposition exists.

F is a function of three arguments:

    ACCUM: The \"accumulator\" argument. INITIAL-VALUE is the initial value of this argument.
    K, J : Two arguments representing the sigma.

N.B.! The sigma_kj are visited in \"right-to-left\" compositional order. That is, if S1, S2, ..., Sk are visited sequentially, then PERM is the composition Sk * ... * S2 * S1."
  (labels ((next (perm k acc)
             (if (zerop k)
                 (values acc t)
                 (let* ((j (perm-eval perm k))
                        (sigma_kj (sigma trans k j)))
                   (if (null sigma_kj)
                       (values nil nil)
                       (next (if (= j k)
                                 perm
                                 (perm-compose (perm-inverse sigma_kj) perm))
                             (1- k)
                             (funcall f acc k j)))))))
    (declare (dynamic-extent #'next))
    (next perm k initial-value)))

(defun trans-decomposition (perm trans &optional (k (perm-size perm)))
  "Decompose PERM into a list of sigmas within the transversal system TRANS. The composition of the sigmas equals the original perm up to K.

The sigma (SIGMA K J) is represented by the cons cell (K . J)."
  ;; XXX: Could avoid NREVERSE by collecting more cleverly.
  (flet ((collector (decomp k j)
           (acons k j decomp)))
    (declare (dynamic-extent #'collector))
    (nreverse (reduce-over-trans-decomposition #'collector nil perm trans k))))

(defun trans-element-p (perm trans &optional (k (perm-size perm)))
  #+#:equivalent (not (null (trans-decomposition perm trans k)))
  (values
   (reduce-over-trans-decomposition
    (load-time-value (constantly t))
    t
    perm
    trans
    k)))

(defvar *context*)
(setf (documentation '*context* 'variable)
      "Special variable used to hold the context being built up for a group.")

(defvar *taus*)
(setf (documentation '*taus* 'variable)
      "Special variable used to hold a mapping between permutation objects (by EQ) to a symbol (one generated by #'TAU-SYMBOL) which is referred to by the SLP context.")

;;; For #'ADD-GENERATOR and #'UPDATE-TRANSVERSAL:
;;;
;;;   * PERM: the perm to introduce to the SGS and transversal system.
;;;
;;;   * SGS: the strong generating set
;;;
;;;   * TRANS: the transversal system
;;;
;;;   * K: All points above K should be fixpoints. K is what is
;;;        recursed on.
;;;
;;;   * SLP: An SLP to construct PERM. Used for recording purposes.
;;;
;;; Both return an updated SGS and transversal system as two values.
;;;
;;; Both also use *CONTEXT* to record SLPs, which is expected to be
;;; bound to. This is indeed the case by the main entry point
;;; #'GENERATE-PERM-GROUP.

;;; Algorithm B from Knuth, with my own modifications.
(defun add-generator (perm sgs trans k slp)
  ;; Add the perm to the SGS.
  (pushnew perm (sgs-ref sgs k))

  ;; Generate a new tau for the perm, and remember it.
  (let ((t-sym (tau-symbol)))
    (setf (gethash perm *taus*) t-sym)
    (setf (symbol-assignment *context* t-sym) slp))

  ;; Process the perm, adding it to the group structure.
  (let ((redo nil))
    (loop
      (loop :for (j . s) :in (transversal-ref trans k)
            :for s-sym := (sigma-symbol k j) :do
              (dolist (tau (sgs-ref sgs k))
                (let ((prod (perm-compose tau s)))
                  (unless (trans-element-p prod trans)
                    (let* ((t-sym (gethash tau *taus*))
                           (prod-slp (compose-slp (slp-symbol t-sym)
                                                  (slp-symbol s-sym))))
                      (multiple-value-setq (sgs trans)
                        (update-transversal prod sgs trans k prod-slp)))

                    (setf redo t)))))

      ;; Break out?
      (unless redo
        (return-from add-generator (values sgs trans)))

      ;; Reset the REDO flag.
      (setf redo nil))))

;;; Algorithm B from Knuth, with my own modifications.
(defun update-transversal (perm sgs trans k slp)
  (let* ((j (perm-eval perm k))
         (sigma (sigma trans k j)))
    (cond
      ((not (null sigma))
       (let ((new-perm (%perm-compose-upto
                        (perm-inverse sigma)
                        perm
                        (1- k))))
         (if (trans-element-p new-perm trans (1- k))
             (values sgs trans)
             (let ((new-perm-slp (compose-slp
                                  (invert-slp
                                   (slp-symbol (sigma-symbol k j)))
                                  slp)))
               (add-generator new-perm sgs trans (1- k) new-perm-slp)))))
      (t
       (setf (sigma trans k j) perm)
       (setf (symbol-assignment *context* (sigma-symbol k j))
             slp)
       (values sgs trans)))))

(defun generate-perm-group (generators)
  "Generate a permutation group generated by the list of permutations GENERATORS."
  (let* ((n (maximum generators :key 'perm-size))
         (sgs (make-sgs n))
         (trans (make-transversal n))
         (fg (make-free-group (length generators)))
         (*context* (make-instance 'slp-context))
         (*taus* (make-hash-table :test 'eq)))
    ;; Initialize TRANS to map sigma_KK: K -> (K -> Identity(K)).
    ;;
    ;; Also record their SLPs as (SLP-ELEMENT <fg identity>).
    (loop :for k :from 1 :to n :do
      (setf (transversal-ref trans k) (make-sigma-table k))
      (setf (symbol-assignment *context* (sigma-symbol k k))
            (slp-element (identity-element fg))))

    ;; Add the generators.
    ;;
    ;; We iterate through the generators of the induced free group
    ;; as well purely to record SLPs. We can then construct a
    ;; homomorphism from the free group to the perm group to
    ;; construct elements from their generators.
    (loop :for generator :in generators
          :for fg-generator :in (generators fg)
          :do (multiple-value-setq (sgs trans)
                (add-generator generator
                               sgs
                               trans
                               n
                               (slp-element fg-generator))))

    ;; Return the group.
    (make-instance 'perm-group
                   :element-size (maximum generators :key #'perm-size)
                   :generators (copy-list generators)
                   :strong-generators sgs
                   :transversal-system trans
                   :slp-context *context*
                   :free-group fg)))

(defun group-bsgs (perm-group)
  "Retrieve a base and associated strong generating set (BSGS) as two values respectively for the permutation group PERM-GROUP."
  (loop :with base := nil
        :with sgs  := nil
        :for k :from 1
        :for k-generators :across (perm-group.strong-generators perm-group)
        :when k-generators :do
          (push k base)
          (push k-generators sgs)
        :finally (return (values base sgs))))

(defun group-from (generators-as-lists)
  "Generate a permutation group from a list of generators, which are represented as lists."
  (generate-perm-group (mapcar #'list-to-perm generators-as-lists)))

;;; TODO: Automatically try calculating size.
(defun group-from-cycles (generators-as-cycles size)
  "Generate a permutation group from a list of generators, which are represented as cycles."
  (generate-perm-group (mapcar (lambda (c)
                                 (from-cycles c size))
                               generators-as-cycles)))

(defun group-order (group)
  "Compute the order of the permutation group GROUP."
  (let ((transversals (perm-group.transversal-system group)))
    (product transversals :key #'length)))

(defun group-element-p (perm group)
  "Decide if the permutation PERM is an element of the group GROUP."
  (trans-element-p perm (perm-group.transversal-system group)))

(defun subgroup-p (group subgroup)
  "Is the group SUBGROUP a subgroup of GROUP?"
  (every (lambda (g) (group-element-p g group))
         (generators subgroup)))

(defun same-group-p (group1 group2)
  "Are the groups GROUP1 and GROUP2 the same (i.e., have the same permutation elements)?"
  (and (subgroup-p group1 group2)
       (subgroup-p group2 group1)))

(defun normal-subgroup-p (group subgroup)
  "Is the group SUBGROUP a normal subgroup of GROUP?"
  (labels ((in-subgroup-p (x)
             (group-element-p x subgroup))
           (normality-criterion (x y)
             ;; x in GROUP
             ;; y in SUBGROUP
             (let ((x-inv (perm-inverse x)))
               (and (in-subgroup-p (perm-compose x (perm-compose y x-inv)))
                    (in-subgroup-p (perm-compose x-inv (perm-compose y x)))))))
    (and (subgroup-p group subgroup)
         (loop :for x :in (generators group)
               :always (loop :for y :in (generators subgroup)
                             :always (normality-criterion x y))))))

;;; XXX FIXME: Avoid consing here.
(defun random-group-element (group)
  "Generate a random element of the group GROUP."
  (reduce #'perm-compose-flipped
          (perm-group.transversal-system group)
          :initial-value (group-identity group)
          :key (lambda (sigma_k) (cdr (random-element sigma_k)))))

;;; XXX: This can be made more efficient by directly reducing over,
;;; removing identities within the fold function.
(defun transversal-decomposition (perm group &key remove-identities)
  "Decompose the permutation PERM into transversal sigmas of the group GROUP."
  (let ((decomp
          (trans-decomposition perm (perm-group.transversal-system group))))
    (if (not remove-identities)
        decomp
        (delete-if (lambda (sigma)
                     (= (car sigma)
                        (cdr sigma)))
                   decomp))))


;;;;;;;;;;;;;;;;; Generator Decomposition Using SLPs ;;;;;;;;;;;;;;;;;

;;; These functions are for pedagogy.

(defun free-group-generator-to-perm-group-generator (perm-group free-group-generator)
  "Convert the free group generator FREE-GROUP-GENERATOR to a generator within the perm group PERM-GROUP."
  (let ((i free-group-generator))
    (cond
      ((zerop i) (group-identity perm-group))
      ((plusp i) (elt (generators perm-group) (1- i)))
      ((minusp i) (perm-inverse
                   (free-group-generator-to-perm-group-generator
                    perm-group
                    (- i)))))))

;; FIXME: We should improve this to use the stuff from
;; homomorphism.lisp, maybe.
(defun free-group->perm-group-homomorphism (free-group perm-group)
  "Construct a homomorphism from the perm group PERM-GROUP's free group to elements of the perm group itself."
  (assert (= (num-generators free-group)
             (num-generators perm-group))
          (free-group perm-group)
          "The free group and the perm group must have the ~
           same number of generators.")
  ;; The perm group contains the free group.
  (lambda (elts)
    (typecase elts
      (integer (free-group-generator-to-perm-group-generator
                perm-group
                elts))
      (list (loop :with result := (group-identity perm-group)
                  :for i :in elts
                  :do (setf result
                            (perm-compose result
                                          (free-group-generator-to-perm-group-generator perm-group i)))
                  :finally (return result))))))

(defun word-simplifier-for-perm-group (g)
  "Construct a simplifier for the permutation group G according to its free group."
  (check-type g perm-group)
  (let* ((n (num-generators g))
         (phi (free-group->perm-group-homomorphism (perm-group.free-group g) g))
         (orders (make-array (1+ n) :initial-element nil))
         (comms  (make-array (1+ n) :initial-element nil)))
    ;; Calculate the orders of the generators.
    (loop :for i :from 1 :to n
          :for g := (funcall phi i)
          :do (setf (aref orders i) (perm-order g)))
    ;; Calculate the commuting ones.
    (loop :for i :from 1 :to n
          :for g1 := (funcall phi i)
          :do (loop :for j :from (1+ i) :to n
                    :for g2 := (funcall phi j)
                    :when (commutesp g1 g2)
                      :do (push j (aref comms i))
                          (push i (aref comms j))))
    ;; Construct the simplifier.
    (word-simplifier orders comms)))

(defun naive-generator-decomposition (perm group &key return-original-generators)
  "Compute the generator decomposition of the permutation PERM of the group GROUP. By default, return a sequence of free generators.

If RETURN-ORIGINAL-GENERATORS is true, return the group's original generators as permutations.

Note: The result is likely very long and inefficient."
  (let* ((d (transversal-decomposition perm group :remove-identities t))
         (ctx (perm-group.slp-context group))
         (fg (perm-group.free-group group))
         (hom (free-group->perm-group-homomorphism fg group)))
    (labels ((to-sigma-symbol (tt)
               (sigma-symbol (car tt) (cdr tt)))
             (find-slp (tt)
               (symbol-assignment ctx (to-sigma-symbol tt)))
             (eval-slp (slp)
               (evaluate-slp fg ctx slp)))
      (mapcar (if return-original-generators hom #'identity) ; Free -> Perm
              (delete (identity-element fg) ; Remove identities.
                      (mapcan #'eval-slp    ; Eval SLPs
                              (mapcar #'find-slp d)))))))

